(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{304:function(t,_,s){"use strict";s.r(_);var a=s(14),n=Object(a.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"互联网是如何运作的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#互联网是如何运作的"}},[t._v("#")]),t._v(" 互联网是如何运作的？")]),t._v(" "),_("h2",{attrs:{id:"_1-网络协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-网络协议"}},[t._v("#")]),t._v(" 1.网络协议")]),t._v(" "),_("p",[t._v("简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。 网络协议通过分层明确每一层的工作职责，通过定义明确的接口来协同工作，每一层都可以使用下面各层的功能，而不必担心各层是如何实现的。")]),t._v(" "),_("h2",{attrs:{id:"_2-tcp-ip协议族"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-tcp-ip协议族"}},[t._v("#")]),t._v(" 2.TCP/IP协议族")]),t._v(" "),_("p",[t._v("CP/IP协议簇是Internet的基础，也是当今最流行的组网形式。TCP/IP是一组协议的代名词，包括许多别的协议，组成了TCP/IP协议簇。")]),t._v(" "),_("p",[t._v("其中比较重要的有SLIP协议、PPP协议、IP协议、ICMP协议、ARP协议、TCP协议、UDP协议、FTP协议、DNS协议、SMTP协议等。")]),t._v(" "),_("p",[t._v("TCP/IP协议并不完全符合OSI的七层参考模型。传统的开放式系统互连参考模型，是一种通信协议的7层抽象的参考模型，其中每一层执行某一特定任务。该模型的目的是使各种硬件在相同的层次上相互通信。而TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。\nTCP/IP协议族分为四层：")]),t._v(" "),_("ol",[_("li",[t._v("应用层：提供特定于应用程序的协议\n（比如负责浏览器和网络服务器相互通信的HTTP协议、负责文件传输的FTP协议、负责电子邮件客户端检索邮件的IMAP协议）")]),t._v(" "),_("li",[t._v("TCP传输控制层：发送数据包到计算机上使用特定端口号的应用程序")]),t._v(" "),_("li",[t._v("IP网络层：使用IP地址将数据包发送到特定的计算机")]),t._v(" "),_("li",[t._v("链路层：将二进制数据包与网络信号相互之间转换\n"),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210105154649473.png",alt:"",title:"RUNOOB"}})])]),t._v(" "),_("h3",{attrs:{id:"_1-ip"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-ip"}},[t._v("#")]),t._v(" 1.IP")]),t._v(" "),_("p",[t._v("IP是不可靠、无连接的协议，它并不关心数据包是否到达目的地，也不关心连接和端口号，IP的工作是"),_("strong",[t._v("发送数据包并将其路由到目标计算机")]),t._v("，其中每个数据包都是独立的互不依赖的，所以有可能会乱序到达目标地址或者在传输途中丢失.")]),t._v(" "),_("p",[t._v("那如何保证数据包到达和顺序正确呢？")]),t._v(" "),_("p",[t._v("这就交给了TCP，这也体现了分层的作用。TCP的工作是确保数据包到达并保持正确的顺序。IP与TCP的唯一共同之处在于它接收数据并将自己的IP首部信息添加到TCP数据。当数据包过大时，在IP层会进行分包，由于每个数据包在物理链路层走的物理链路不一样，传输速度也不一样，导致数据包没有按顺序到达目的地，但TCP会根据数据包上携带的序列号来进行排序重组，并且发送方在一个特定时间内没有接收到接收方的ack确认时，则发送方会重新传送该数据包。【超时重传】")]),t._v(" "),_("p",[t._v("IP≠IP地址，IP是网络层协议，而IP地址是一串数字，IP地址有两种标准，一种称为IPv4（采用32位地址）、IPv6（采用128位地址）")]),t._v(" "),_("p",[t._v("两级的 IP 地址可以记为：")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[t._v("IP 地址 ::= { <网络号>, <主机号>}\n\n::= 代表“定义为”\n")])])]),_("p",[t._v("IP 地址中的网络号字段和主机号字段 :\n"),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210106101704803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzUxNDY1,size_16,color_FFFFFF,t_70",alt:"",title:"RUNOOB"}}),t._v("\n1-127 大型网络；\n128-191中等网络；\n192-223小型网络；\n划分子网后 IP 地址就变成了三级结构。划分子网只是把 IP 地址的主机号 host-id 这部分进行再划分，而不改变 IP 地址原来的网络号 net-id。")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[t._v("IP地址 ::= {<网络号>, <子网号>, <主机号>}\n")])])]),_("p",[_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210106103952655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzUxNDY1,size_16,color_FFFFFF,t_70",alt:"",title:"RUNOOB"}}),t._v(" "),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210106103908311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzUxNDY1,size_16,color_FFFFFF,t_70",alt:"",title:"RUNOOB"}}),t._v("\n子网掩码：")]),t._v(" "),_("p",[t._v("从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码(subnet mask)可以找出 IP 地址中的子网部分。")]),t._v(" "),_("p",[t._v("子网掩码存储在路由表。")]),t._v(" "),_("p",[t._v("划分子网增加了灵活性，但是却减少了能够连接在网络上的主机总数（各个相对对立的网点，主机号0和1是不能取的，需要留给网络地址和广播地址。因此每多一个子网，就必须浪费两个IP地址）。\n"),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210106104341838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzUxNDY1,size_16,color_FFFFFF,t_70",alt:"",title:"RUNOOB"}}),t._v("\n(IP 地址) AND (子网掩码) =子网网络地址\n"),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210106102949487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzUxNDY1,size_16,color_FFFFFF,t_70",alt:"",title:"RUNOOB"}}),t._v("\n网际层的IP协议及配套协议：\n"),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210106101428827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzUxNDY1,size_16,color_FFFFFF,t_70",alt:"",title:"RUNOOB"}}),t._v("\nIP地址与硬件地址的区别：")]),t._v(" "),_("p",[t._v("物理地址（硬件地址）放在MAC帧的首部，是数据链路层和物理层使用的地址，而IP地址放在IP数据报的首部，是网络层和以上各层使用的地址，是一种逻辑地址。")]),t._v(" "),_("p",[t._v("主机或路由器怎样知道应当在MAC帧的首部填入什么样的硬件地址？")]),t._v(" "),_("p",[t._v("通过"),_("strong",[t._v("地址解析协议 ARP")]),t._v("：从网络层使用的IP地址，解析出数据链路层使用的硬件地址。\n每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表，并且这个映射表经常动态更新（新增或超时删除）\n"),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210106102549755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzUxNDY1,size_16,color_FFFFFF,t_70",alt:"",title:"RUNOOB"}})]),t._v(" "),_("h3",{attrs:{id:"_2-传输控制协议tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-传输控制协议tcp"}},[t._v("#")]),t._v(" 2.传输控制协议TCP")]),t._v(" "),_("p",[t._v("Tcp通过协议栈将数据路由到目标计算机上的正确的应用程序。")]),t._v(" "),_("p",[t._v("（1）TCP 是面向连接的运输层协议。面向连接意味着两个使用TCP的应用程序在交换数据之前必须先建立连接.")]),t._v(" "),_("p",[t._v("（2）每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定，每一条 TCP 连接只能是点对点的（一对一）。")]),t._v(" "),_("p",[t._v("（3）TCP 提供可靠交付的服务。因为对于接收到的每个数据包，都会向发送方发送确认以确认发送。TCP还在其报头中包含一个校验和，以检查接收到的数据（无差错、不丢失、不重复并且按序到达）。")]),t._v(" "),_("p",[t._v("（4） TCP 提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。")]),t._v(" "),_("p",[t._v("（5）面向字节流。\n流：流入进程或者从进程流出的字节序列。\nTCP报文段的首部格式：\n"),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210105154345149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzUxNDY1,size_16,color_FFFFFF,t_70",alt:"",title:"RUNOOB"}}),t._v("\nTCP建立连接（三次握手四次挥手）：")]),t._v(" "),_("p",[t._v("第一次握手：A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。发送完毕后客户端进入SYN_SEND状态。\n注意：SYN=1请求报文段不能携带数据，但是要消耗掉一个序号")]),t._v(" "),_("p",[t._v("第二次握手： B 的 TCP 收到连接请求报文段后，如同意，则发回确认。B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x + 1，自己选择的序号 seq = y。发送完毕后服务器端进入SYN_RECEIVED状态。\n注意：SYN=1确认报文段不能携带数据，但是要消耗掉一个序号")]),t._v(" "),_("p",[t._v("第三次握手： A 收到此报文段后向 B 给出确认，其 ACK = 1， 确认号 ack = y + 1。\nA 的 TCP 通知上层应用进程，连接已经建立。发送完毕后客户端进入ESTABLISHED状态,服务器端接收到包后也会进入ESTABLISHED状态，TCP握手结束。\n注意：ACK报文段可以携带数据，但如果不携带数据则不消耗序号。")]),t._v(" "),_("p",[t._v("思考：为什么在TCP连接建立过程中，发送方A为什么还要发送一次确认呢？")]),t._v(" "),_("p",[t._v("为了防止已经失效的连接请求报文段突然又传送到B\n"),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210107151434913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzUxNDY1,size_16,color_FFFFFF,t_70",alt:"",title:"RUNOOB"}}),t._v("\n第一次挥手： 数据传输结束后，通信的双方都可释放连接。\n现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据（但仍可以接收数据），主动关闭 TCP 连接。\nA 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。\n注意：FIN报文段即使不携带数据，它也要消耗掉一个序号")]),t._v(" "),_("p",[t._v("第二次挥手： B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v。\nTCP 服务器进程通知高层应用进程。\n从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。")]),t._v(" "),_("p",[t._v("第三次挥手： 若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。")]),t._v(" "),_("p",[t._v("第四次挥手： A 收到连接释放报文段后，必须发出确认。\n在确认报文段中 ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。\n"),_("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210107151618951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzUxNDY1,size_16,color_FFFFFF,t_70",alt:"",title:"RUNOOB"}})])])}),[],!1,null,null,null);_.default=n.exports}}]);